#include <SimpleCOMM.h>
#define DEBUG
	SimpleCOMM::SimpleCOMM(Omni4WDSR* pOmni,bool isHead)
	{
		this->_omni = pOmni;
		this->datSize = 0;
		recvFlag = RECE_UNKNOW;
		lastMotion = STAT_STOP;
	}
	unsigned char SimpleCOMM::recvMsg(unsigned char desiredSize,unsigned char ms)
	{
		unsigned char ibyte;
		unsigned long endtime = millis() + ms;
		if(recvFlag == RECE_BEGIN) recvFlag = RECE_SECONDTIME;
		while(datSize < desiredSize && (ibyte =Serial.read()) != 0xff && millis() < endtime)
		{
			if(datSize == 0 && ((ibyte - 0x30) != EEPROM.read(ADDR))) {return recvFlag;}
			if(datSize == 0 && ((ibyte - 0x30) == EEPROM.read(ADDR))) recvFlag = RECE_BEGIN;
			_buff[datSize++] = ibyte;
		}
		if(datSize == 2) {recvFlag = RECE_SUCCEEDED;}
		if(datSize != 2 && recvFlag == RECE_SECONDTIME) clearBuf();
		return recvFlag;
	}
	unsigned char SimpleCOMM::replyMsg(unsigned char* pFlag)
	{
		
		if(recvFlag != RECE_SUCCEEDED) {return NULL;}
		unsigned char motion = STAT_UNKNOWN;
		unsigned int duration = 1000;
		unsigned char speed = 160;
		unsigned int uptime = 500;
		unsigned int stepMs = 100;
		switch(_buff[1]) 
		{
			case '5':
			#ifdef DEBUG
				Serial.println("set car Stop");
			#endif
			motion = STAT_STOP;break;
			case '8':
			#ifdef DEBUG
				Serial.println("set car Ahead");
			#endif
			motion = STAT_ADVANCE;duration = 3000;break;
			case '2':
			#ifdef DEBUG
				Serial.println("set car Backoff");
			#endif
			motion = STAT_BACKOFF; duration = 3000;break;
			case '6':
			#ifdef DEBUG
				Serial.println("set car	TurnRight");
			#endif
			motion = STAT_RIGHT;duration = 3000;break;
			case '4':
			#ifdef DEBUG
				Serial.println("set car TurnLeft");
			#endif
			motion = STAT_LEFT;duration = 3000;break;
			case '0':
			#ifdef DEBUG
				Serial.println("set car RotateLeft");
			#endif
			motion = STAT_ROTATELEFT;break;
			case '.':
			#ifdef DEBUG
				Serial.println("set car RotateRight");
			#endif
			motion = STAT_ROTATERIGHT;break;
			case '7':
			#ifdef DEBUG
				Serial.println("set car UpperLeft");
			#endif
			motion = STAT_UPPERLEFT;duration = 3000;break;
			case '1':
			#ifdef DEBUG
				Serial.println("set car LowerLeft");
			#endif
			motion = STAT_LOWERLEFT; duration = 3000;break;
			case '3':
			#ifdef DEBUG
				Serial.println("set car LowerRight");
			#endif
			motion = STAT_LOWERRIGHT;duration = 3000;break;
			case '9':
			#ifdef DEBUG
				Serial.println("set car UpperRight");
			#endif
			motion = STAT_UPPERRIGHT;duration = 3000;break;
			case 't':
			*pFlag = _COMM;Serial.println("turnMode succeed");break;
			case '*': 
			#ifdef DEBUG
				Serial.println("Sonar Update");
			#endif
			sonarsUpdate();
			clearBuf();
			return NULL; break;
			default:motion = STAT_STOP; break;
		}
		clearBuf();
		unsigned char counter = 0;
		bool isNull = _omni->actIsNull();
		if(!isNull) {_omni->del(true); _omni->addAction(lastMotion,speed,stepMs,uptime,true);}
		for(int i = 0; i < (duration/stepMs)-1;++i) _omni->addAction(motion,speed,stepMs,0);
		_omni->addAction(motion,speed,stepMs,uptime,true);
		lastMotion = motion;
		return counter;	
	}
	void SimpleCOMM::showDat()
	{
		for(int i = 0; i < sizeof(_buff); ++i)
		{
			Serial.print(*(_buff+i),HEX);
			Serial.print(' ');
		}
		Serial.println();
	}
	
	void SimpleCOMM::clearBuf()
	{
		_buff[0] = 0x00;
		_buff[1] = 0x00;
		recvFlag = RECE_UNKNOW;
		datSize = 0;
	}
	
	unsigned char SimpleCOMM::getRecvStat()
	{
		return recvFlag;
	}
	static unsigned char sonarCurr = Omni4WDSR::POS_LEFT;
	unsigned char SimpleCOMM::sonarsUpdate() 
	{
		if(sonarCurr==Omni4WDSR::POS_HEAD) sonarCurr=Omni4WDSR::POS_LEFT;
		else ++sonarCurr;      
		_omni->getSONARDist(sonarCurr); 
		if(sonarCurr == Omni4WDSR::POS_HEAD)
		{ 
			_omni->updateSafeDistBitmap();
			_omni->updateSafeActionsBitmap();	
		}
		return sonarCurr;
	}
	